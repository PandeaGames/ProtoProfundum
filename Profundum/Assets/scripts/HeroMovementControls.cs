//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System.Collections;
using MonsterLove.StateMachine; 

public class HeroMovementControls : StateBehaviour 
{
	private float _x_move = 0;
	private float _y_move = 0;
	private bool _stride = false;
	private float _speed = 0;
	private Vector3 _bodyAngle;
	private Vector3 _angleVector;
	private bool _flipping = false;
	private Vector3 _prev_control_vector;
	private float _control_vector_delta;
	private float _prev_control_vector_delta;
	private float _control_angle;
	private float _control_angle_delta;


	public float maxRunSpeed = 5;
	public float maxWalkSpeed = 2.5f;
	public float friction = 1.20f;
	public float stopFriction = 1.05f;
	public GameObject cam;
	public HeroMovementControls ()
	{
	}

	void Awake()
	{
	}

	void Start()
	{
		cam = Camera.main.gameObject;
	}

	void Update()
	{
		_x_move = Input.GetAxis("JoystickLeftHorizontal"); 
		_y_move = Input.GetAxis("JoystickLeftVertical"); 

		_y_move += Input.GetKey ("up") ? -1 : 0;
		_y_move += Input.GetKey ("down") ? 1 : 0;
		_x_move += Input.GetKey ("right") ? 1 : 0;
		_x_move += Input.GetKey ("left") ? -1 : 0;
		
		float cam_delta_x = cam.transform.position.x - GetComponent<Rigidbody>().transform.position.x;
		float cam_delta_z = cam.transform.position.z - GetComponent<Rigidbody>().transform.position.z;
		
		float cam_angle = Mathf.Atan2(cam_delta_x, cam_delta_z);
		
		float control_angle = Mathf.Atan2(_y_move, _x_move) + 1.5f;
		float control_vector = Mathf.Sqrt(_x_move * _x_move + _y_move * _y_move);
		Vector3 control_angle_vector = new Vector3(_x_move, 0, _y_move);
		if(_prev_control_vector !=null)
		{
			_control_angle_delta = Vector3.Angle(control_angle_vector, _prev_control_vector);
		}
		_control_vector_delta = Mathf.Abs(_prev_control_vector_delta - control_vector);
		_prev_control_vector_delta = control_vector;
		_prev_control_vector = control_angle_vector;
		
		float angle = cam_angle+control_angle;
		_angleVector.Set(Mathf.Cos(angle), 0, Mathf.Sin(angle));
		
		float runRange = 1;
		float walkRange = 0.25f;
		float turnRange = 0.03f;
		
		bool running = control_vector >= runRange ? true:false;
		bool walking = !running && control_vector >walkRange;
		bool turning = !walking && !running && control_vector > turnRange;
		
		
		float slerpSpeed = 0.0f;
		_stride = false;
		float vel = 0;
		if(running)
		{
			//vel = control_vector/20;
			if(_speed>maxRunSpeed / friction) 
			{
				_speed = maxRunSpeed;
				_stride = true;
			}
			slerpSpeed = 0.1f;
		}
		else if(walking)
		{
			//vel = control_vector/50;
			if(_speed>maxWalkSpeed) 
			{
				
				_stride = true;
			}
			slerpSpeed = 0.05f;
			//speed = 0.5;
		}
		else if(turning)
		{	
			slerpSpeed = 0.01f;
			//speed = 0;
		}
		else
		{
			//speed = 0;
		}
		if(control_vector >=1)
		{
			_stride = true;
		}
		else
		{
			_stride = false;
		}
		if(!turning) vel = (control_vector - walkRange) / 20;
		Vector3 targetDir = _bodyAngle - _angleVector;
		Vector3 forward = transform.forward;
		float a = Vector3.Angle(_bodyAngle, _angleVector);
		
		if (a < 10F || _stride)
		{
			//speed += vel;
			_speed = vel*40;
		}
		
		if (a < 5F)
		{
			_flipping = false;
		}
		
		if(_flipping)
		{
			slerpSpeed = 0.4f;
			//speed=0;
			//bodyAngle = angleVector;
		}
		
		if(control_vector < turnRange)
		{
			_speed= _speed / stopFriction;
		}
		
		_speed = (_speed) / friction;
		_bodyAngle = Vector3.Slerp(_bodyAngle, _angleVector, slerpSpeed);
		
		
		
		var deltaAngle = Vector3.AngleBetween(_bodyAngle, _angleVector);
		
		//Debug.Log(control_angle_delta);
		
		
		
		float strength = Mathf.Sqrt(_x_move * _x_move + _y_move * _y_move) /10;
		Vector3 newVel = (transform.forward * (_speed * 5));//override Z and X movement
		newVel.y = GetComponent<Rigidbody>().velocity.y;//retain gravity values
		GetComponent<Rigidbody>().velocity =  newVel;
		GetComponent<Rigidbody>().transform.rotation = Quaternion.AngleAxis(Mathf.Atan2(_bodyAngle.z, _bodyAngle.x)/(Mathf.PI/180)+180, Vector3.up);
	}

}
/*
function Start () {
	anim = gameObject.GetComponent(Animator);
}

function Update () {
	
	//
	
	if(stateMachine.currentState != States.Idle && stateMachine.currentState != States.Walking)
	{
		return;
	}
	
	x_move = Input.GetAxis("JoystickLeftHorizontal"); 
	y_move = Input.GetAxis("JoystickLeftVertical"); 
	
	var cam_delta_x:float = cam.transform.position.x - rigidbody.transform.position.x;
	var cam_delta_z:float = cam.transform.position.z - rigidbody.transform.position.z;
	
	var cam_angle:float = Mathf.Atan2(cam_delta_x, cam_delta_z);
	
	var control_angle:float = Mathf.Atan2(y_move, x_move) + 1.5;
	var control_vector:float = Mathf.Sqrt(x_move * x_move + y_move * y_move);
	var control_angle_vector:Vector3 = new Vector3(x_move, 0, y_move);
	if(prev_control_vector !=null)
	{
		control_angle_delta = Vector3.Angle(control_angle_vector, prev_control_vector);
	}
	control_vector_delta = Mathf.Abs(prev_control_vector_delta - control_vector);
	prev_control_vector_delta = control_vector;
	prev_control_vector = control_angle_vector;
	
	var angle:float = cam_angle+control_angle;
	angleVector.Set(Mathf.Cos(angle), 0, Mathf.Sin(angle));
	
	var runRange:float = 1;
	var walkRange:float = 0.25;
	var turnRange:float = 0.03;
	
	var running:boolean = control_vector >= runRange ? true:false;
	var walking:boolean = !running && control_vector >walkRange;
	var turning:boolean = !walking && !running && control_vector > turnRange;
	
	
	var slerpSpeed:float = 0.0;
	stride = false;
	var vel:float = 0;
	if(running)
	{
		//vel = control_vector/20;
		if(speed>maxRunSpeed / friction) 
		{
			speed = maxRunSpeed;
			stride = true;
		}
		slerpSpeed = 0.1;
	}
	else if(walking)
	{
		//vel = control_vector/50;
		if(speed>maxWalkSpeed) 
		{
			
			stride = true;
		}
		slerpSpeed = 0.05;
		//speed = 0.5;
	}
	else if(turning)
	{	
		slerpSpeed = 0.01;
		//speed = 0;
	}
	else
	{
		//speed = 0;
	}
	if(control_vector >=1)
	{
		stride = true;
	}
	else
	{
		stride = false;
	}
	if(!turning) vel = (control_vector - walkRange) / 20;
	var targetDir:Vector3 = bodyAngle - angleVector;
	var forward:Vector3 = transform.forward;
	var a:float = Vector3.Angle(bodyAngle, angleVector);
	
	if (a < 10F || stride)
	{
		//speed += vel;
		speed = vel*40;
	}
	
	if (a < 5F)
	{
		flipping = false;
	}
	
	if(flipping)
	{
		slerpSpeed = 0.4;
		//speed=0;
		//bodyAngle = angleVector;
	}
	
	if(control_vector < turnRange)
	{
		speed= speed / stopFriction;
	}
	
	speed = (speed) / friction;
	bodyAngle = Vector3.Slerp(bodyAngle, angleVector, slerpSpeed);
	
	
	
	var deltaAngle = Vector3.AngleBetween(bodyAngle, angleVector);
	
	//Debug.Log(control_angle_delta);
	
	
	
	var strength:float = Mathf.Sqrt(x_move * x_move + y_move * y_move) /10;
	anim.SetFloat("speed", speed);
	var newVel:Vector3 = (transform.forward * (speed * 5));//override Z and X movement
	newVel.y = rigidbody.velocity.y;//retain gravity values
	rigidbody.velocity =  newVel;
	rigidbody.transform.rotation = Quaternion.AngleAxis(Mathf.Atan2(bodyAngle.z, bodyAngle.x)/(Mathf.PI/180)+180, Vector3.up);
	
	if(running || walking)
	{
		stateMachine.ChangeState(States.Walking);
	}
	else
	{
		stateMachine.ChangeState(States.Idle);
	}
}
public function Jump(strength:float)
{
	stateMachine.ChangeState(States.Jumping);
	transform.position = transform.position + Vector3.up * 0.5;
	rigidbody.velocity = Vector3.zero;
	rigidbody.AddForce(Vector3.up * strength + transform.forward * strength, ForceMode.VelocityChange);
}
function OnCollisionEnter(collision:Collision)
{
	if(stateMachine.currentState == States.Jumping && (collision.other.tag == "Ground" || collision.other.tag == "Bridge"))
	{
		stateMachine.ChangeState(States.Idle);
	}
}
function UpdateState(state:States)
{
	if(state == States.Jumping)
	{
		rigidbody.constraints = RigidbodyConstraints.FreezeRotationX | RigidbodyConstraints.FreezeRotationZ | RigidbodyConstraints.FreezeRotationY;
	}
	else
	{
		rigidbody.constraints = RigidbodyConstraints.FreezeRotationX | RigidbodyConstraints.FreezeRotationZ;
	}g;
}
*/
